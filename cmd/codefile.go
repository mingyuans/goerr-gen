package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"math"
	"math/rand"
	"path/filepath"
	"strings"
)

const (
	codePackagePath = "github.com/mingyuans/goerr-gen/codegen"
)

type codeFileGenerator struct {
	buf bytes.Buffer // Accumulated output.
}

func GenerateCodeFile(arg Arg, sets []ErrorCodePackage) error {
	codeGen := codeFileGenerator{}
	return codeGen.generateCodeFile(arg, sets)
}

// generateCodeFile produces the register calls for the named type.
func (g *codeFileGenerator) generateCodeFile(arg Arg, sets []ErrorCodePackage) error {
	genCodeFilePath := arg.CodeOutput
	if isDirectory(genCodeFilePath) {
		genCodeFilePath = filepath.Join(genCodeFilePath, "code_gen.go")
	}

	outputPackageName := filepath.Base(filepath.Dir(genCodeFilePath))

	g.Printf("// Code generated by \"codegen\"; DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package %s", outputPackageName)
	g.Printf("\n")

	g.Printf("import %s \"%s\"\n", "code", codePackagePath)

	pkgCodes := make(map[string][]Value)
	for _, codeSet := range sets {
		if len(codeSet.codes) == 0 {
			continue
		}

		var pkgName = strings.ToLower(codeSet.packageName)
		if _, ok := pkgCodes[pkgName]; ok || pkgName == preservePackageName {
			//generate random number to avoid conflict
			pkgName = fmt.Sprintf("%s_%d", pkgName, rand.Intn(math.MaxUint8))
		}
		pkgCodes[pkgName] = codeSet.codes

		g.Printf("import %s \"%s\"\n", pkgName, codeSet.packagePath)
	}

	g.Printf("\t// init register error codes defines in this source code to `github.com/mingyuans/errors`\n")
	g.Printf("func init() {\n")

	for pkgName, values := range pkgCodes {
		for _, value := range values {
			if !strings.HasPrefix(strings.ToLower(value.name), "err") {
				if strings.ToLower(value.name) != "success" {
					log.Printf("Field %s does not follow the naming convention, please use `Err` as the prefix.I will skip it first\n", value.name)
					continue
				}
			}

			codeUint, description := value.ParseComment()
			g.Printf("\tcode.Register(%s.%s, %s, \"%s\")\n", pkgName, value.name, codeUint, description)
		}
	}
	g.Printf("}\n")
	formatedBytes := formatCodeFile(g.buf)
	return writeToFile(formatedBytes, genCodeFilePath)
}

func (g *codeFileGenerator) Printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

// formatCodeFile returns the gofmt-ed contents of the Generator's buffer.
func formatCodeFile(buf bytes.Buffer) []byte {
	src, err := format.Source(buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return buf.Bytes()
	}
	return src
}
