package cmd

import (
	"bytes"
	"fmt"
	"go/format"
	"golang.org/x/tools/go/packages"
	"log"
	"math"
	"math/rand"
	"path/filepath"
	"strings"
)

const (
	codePackagePath     = "github.com/mingyuans/goerr-gen/codegen"
	preservePackageName = "code"
)

type codeFileGenerator struct {
	buf bytes.Buffer // Accumulated output.
}

func GenerateCodeFile(arg Arg, sets []ErrorCodePackage) error {
	codeGen := codeFileGenerator{}
	return codeGen.generateCodeFile(arg, sets)
}

// generateCodeFile produces the register calls for the named type.
func (g *codeFileGenerator) generateCodeFile(arg Arg, sets []ErrorCodePackage) error {
	genCodeFilePath := arg.CodeOutput
	if isDirectory(genCodeFilePath) {
		genCodeFilePath = filepath.Join(genCodeFilePath, "code_gen.go")
	}

	outputPackageName := filepath.Base(filepath.Dir(genCodeFilePath))
	outputPackagePath, getPackageErr := GetPackagePath(filepath.Dir(genCodeFilePath))
	if getPackageErr != nil {
		log.Printf("GetPackagePath err: %v", getPackageErr)
	}

	g.Printf("// Code generated by \"codegen\"; DO NOT EDIT.\n")
	g.Printf("\n")
	g.Printf("package %s", outputPackageName)
	g.Printf("\n")
	g.Printf("import %s \"%s\"\n", "code", codePackagePath)

	pkgCodes := make(map[string][]Value)
	for _, codeSet := range sets {
		if len(codeSet.codes) == 0 {
			continue
		}

		var pkgName = strings.ToLower(codeSet.packageName)
		//Don't import itself if the gen file is located in the same package
		if codeSet.packagePath == outputPackagePath {
			pkgName = ""
		} else if _, ok := pkgCodes[pkgName]; ok || pkgName == preservePackageName {
			//generate random number to avoid conflict
			pkgName = fmt.Sprintf("%s_%d", pkgName, rand.Intn(math.MaxUint8))
		}

		pkgCodes[pkgName] = codeSet.codes

		if pkgName == "" {
			continue
		}

		g.Printf("import %s \"%s\"\n", pkgName, codeSet.packagePath)
	}

	g.Printf("\t// init register error codes defines in this source code to `github.com/mingyuans/errors`\n")
	g.Printf("func init() {\n")

	for pkgName, values := range pkgCodes {
		for _, value := range values {
			if !strings.HasPrefix(strings.ToLower(value.name), "err") {
				if strings.ToLower(value.name) != "success" {
					log.Printf("Field %s does not follow the naming convention, please use `Err` as the prefix.I will skip it first\n", value.name)
					continue
				}
			}

			codeUint, description := value.ParseComment()
			var valueName = fmt.Sprintf("%s.%s", pkgName, value.name)
			if pkgName == "" {
				valueName = value.name
			}

			g.Printf("\tcode.Register(%s, %s, \"%s\")\n", valueName, codeUint, description)
		}
	}
	g.Printf("}\n")
	formatedBytes := formatCodeFile(g.buf)
	return writeToFile(formatedBytes, genCodeFilePath)
}

func (g *codeFileGenerator) Printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

// formatCodeFile returns the gofmt-ed contents of the Generator's buffer.
func formatCodeFile(buf bytes.Buffer) []byte {
	src, err := format.Source(buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return buf.Bytes()
	}
	return src
}

// GetPackagePath takes a directory path and returns the corresponding Go package path.
func GetPackagePath(dir string) (string, error) {
	cfg := &packages.Config{
		Mode: packages.NeedName,
	}

	pkgs, err := packages.Load(cfg, dir)
	if err != nil {
		fmt.Printf("Error loading packages: %v\n", err)
		return "", err
	}

	if len(pkgs) == 0 {
		fmt.Println("No packages found.")
		return "", nil
	}
	return pkgs[0].PkgPath, nil
}
